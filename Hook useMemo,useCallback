What useMemo Does

useMemo lets you memoize (remember) a computed value so that it doesn't get recalculated on every render, unless its dependencies change.
This is useful when:

The calculation is expensive (takes time or resources).

You want to avoid unnecessary re-computations when unrelated state changes.

Basic Example
import React, { useState, useMemo } from "react";

export default function UseMemoExample() {
  const [count, setCount] = useState(0);
  const [theme, setTheme] = useState(false);

  // Expensive calculation (just for demo)
  const expensiveCalculation = (num) => {
    console.log("Calculating...");
    for (let i = 0; i < 1000000000; i++) {} // simulate heavy work
    return num * 2;
  };

  // useMemo caches the result until 'count' changes
  const doubleCount = useMemo(() => {
    return expensiveCalculation(count);
  }, [count]);

  return (
    <div style={{ background: theme ? "black" : "white", color: theme ? "white" : "black", padding: "20px" }}>
      <h2>Count: {count}</h2>
      <p>Double Count: {doubleCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setTheme(!theme)}>Toggle Theme</button>
    </div>
  );
}

Why useMemo Helps Here

Without useMemo, the expensiveCalculation runs every time any state changes (even theme), which slows the UI.

With useMemo, it only recalculates when count changes.

Real-World Practical Example — Filtering Large Data

Imagine you have 10,000 products and a search filter. You don’t want to filter the list again every time some unrelated state changes (like a theme toggle).

import React, { useState, useMemo } from "react";

const products = new Array(10000).fill(0).map((_, i) => ({
  id: i,
  name: `Product ${i}`
}));

export default function ProductSearch() {
  const [search, setSearch] = useState("");
  const [theme, setTheme] = useState(false);

  const filteredProducts = useMemo(() => {
    console.log("Filtering products...");
    return products.filter((p) =>
      p.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [search]); // Only filter when search changes

  return (
    <div style={{ background: theme ? "#333" : "#fff", color: theme ? "#fff" : "#000", padding: "20px" }}>
      <h2>Product Search</h2>
      <input
        type="text"
        placeholder="Search product..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <button onClick={() => setTheme(!theme)}>Toggle Theme</button>
      <ul>
        {filteredProducts.slice(0, 20).map((p) => (
          <li key={p.id}>{p.name}</li>
        ))}
      </ul>
    </div>
  );
}

Where This Helps in the Real World

Large datasets (products, customers, orders, etc.).

Complex calculations (e.g., data analytics, sorting, filtering).

Optimizing performance in dashboards or tables where state changes often but the expensive work should only happen when relevant inputs change.

✅ Rule of Thumb: Use useMemo only when performance issues occur due to unnecessary recalculations. Overusing it for everything can make code harder to maintain.

2. useCallback Hook
The useCallback hook is used to memoize a callback function, which ensures that the function reference doesn't change between 
renders unless its dependencies change. This is useful for passing stable functions as props to child components, avoiding
unnecessary re-renders.

Syntax:

const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
Callback function: The function to be memoized.
Dependencies array: The list of variables that, when changed, will update the function.
Example:

import React, { useState, useCallback } from 'react';

function ParentComponent() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  return (
    <div>
      <ChildComponent increment={increment} />
      <p>Count: {count}</p>
    </div>
  );
}

function ChildComponent({ increment }) {
  return <button onClick={increment}>Increment</button>;
}
In this example:

The increment function is memoized using useCallback, so it doesn't get recreated on every render unless its dependencies change.

3. useReducer Hook
The useReducer hook is a more advanced state management tool than useState. It is typically used when you have complex state logic 
that involves multiple sub-values or when the next state depends on the previous state.

Syntax:

const [state, dispatch] = useReducer(reducer, initialState);
reducer: A function that receives the current state and an action, and returns the new state.
initialState: The initial value of the state.
dispatch: A function to send actions to the reducer.
Example:

import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
    </div>
  );
}
In this example:

useReducer manages the counter state by dispatching actions to a reducer function that handles the state changes based on the 
action type.

Key Differences:

useMemo: Memoizes the result of a function to optimize performance.

useCallback: Memoizes a function itself to prevent unnecessary re-creations.

useReducer: An alternative to useState for managing complex state logic.

These hooks are especially useful when dealing with performance optimization and more complex state management in React applications.

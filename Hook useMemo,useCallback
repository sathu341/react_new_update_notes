************************************************************** ðŸ“• What useMemo Does  *************************************************************************

useMemo lets you memoize (remember) a computed value so that it doesn't get recalculated on every render, unless its dependencies change.
This is useful when:

The calculation is expensive (takes time or resources).

You want to avoid unnecessary re-computations when unrelated state changes.

Basic Example
import React, { useState, useMemo } from "react";

export default function UseMemoExample() {
  const [count, setCount] = useState(0);
  const [theme, setTheme] = useState(false);

  // Expensive calculation (just for demo)
  const expensiveCalculation = (num) => {
    console.log("Calculating...");
    for (let i = 0; i < 1000000000; i++) {} // simulate heavy work
    return num * 2;
  };

  // useMemo caches the result until 'count' changes
  const doubleCount = useMemo(() => {
    return expensiveCalculation(count);
  }, [count]);

  return (
    <div style={{ background: theme ? "black" : "white", color: theme ? "white" : "black", padding: "20px" }}>
      <h2>Count: {count}</h2>
      <p>Double Count: {doubleCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setTheme(!theme)}>Toggle Theme</button>
    </div>
  );
}

Why useMemo Helps Here

Without useMemo, the expensiveCalculation runs every time any state changes (even theme), which slows the UI.

With useMemo, it only recalculates when count changes.

Real-World Practical Example â€” Filtering Large Data

Imagine you have 10,000 products and a search filter. You donâ€™t want to filter the list again every time some unrelated state changes (like a theme toggle).

import React, { useState, useMemo } from "react";

const products = new Array(10000).fill(0).map((_, i) => ({
  id: i,
  name: `Product ${i}`
}));

export default function ProductSearch() {
  const [search, setSearch] = useState("");
  const [theme, setTheme] = useState(false);

  const filteredProducts = useMemo(() => {
    console.log("Filtering products...");
    return products.filter((p) =>
      p.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [search]); // Only filter when search changes

  return (
    <div style={{ background: theme ? "#333" : "#fff", color: theme ? "#fff" : "#000", padding: "20px" }}>
      <h2>Product Search</h2>
      <input
        type="text"
        placeholder="Search product..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <button onClick={() => setTheme(!theme)}>Toggle Theme</button>
      <ul>
        {filteredProducts.slice(0, 20).map((p) => (
          <li key={p.id}>{p.name}</li>
        ))}
      </ul>
    </div>
  );
}

Where This Helps in the Real World

Large datasets (products, customers, orders, etc.).

Complex calculations (e.g., data analytics, sorting, filtering).

Optimizing performance in dashboards or tables where state changes often but the expensive work should only happen when relevant inputs change.

âœ… Rule of Thumb: Use useMemo only when performance issues occur due to unnecessary recalculations. Overusing it for everything can make code harder to maintain.

*******************************************************************************ðŸŽˆ What useCallback Does ************************************************************

useCallback returns a memoized function that only changes when its dependencies change.
Itâ€™s used to prevent re-creation of functions on every render, which is helpful when:

Passing functions as props to child components (avoiding unnecessary re-renders).

Avoiding function identity change when dependencies didnâ€™t change.

Basic Example
import React, { useState, useCallback } from "react";

function Button({ onClick, children }) {
  console.log(`Rendering button: ${children}`);
  return <button onClick={onClick}>{children}</button>;
}

export default function UseCallbackExample() {
  const [count, setCount] = useState(0);
  const [theme, setTheme] = useState(false);

  // Without useCallback, this function is recreated every render
  const increment = useCallback(() => {
    setCount((c) => c + 1);
  }, []); // Dependencies: none

  return (
    <div style={{ background: theme ? "black" : "white", color: theme ? "white" : "black", padding: "20px" }}>
      <h2>Count: {count}</h2>
      <Button onClick={increment}>Increment</Button>
      <Button onClick={() => setTheme(!theme)}>Toggle Theme</Button>
    </div>
  );
}

Why useCallback Helps Here

Without useCallback, increment is a new function on every render.

If <Button> is memoized with React.memo, it would still re-render because the onClick prop is "different" each time.

With useCallback, the same function reference is reused until dependencies change.

Real-World Practical Example â€” Search with Debounce

Imagine a search box where the search function is passed down to a child component that handles API calls with debounce.
We donâ€™t want the debounce to reset on every render just because the parent re-rendered.

import React, { useState, useCallback } from "react";

function SearchInput({ onSearch }) {
  console.log("Rendering SearchInput...");
  return (
    <input
      type="text"
      placeholder="Search..."
      onChange={(e) => onSearch(e.target.value)}
    />
  );
}

export default function SearchPage() {
  const [results, setResults] = useState([]);

  const fetchResults = useCallback((query) => {
    console.log(`Searching for: ${query}`);
    // Imagine calling an API here
    setResults([`Result for "${query}"`]);
  }, []); // No dependencies â†’ function won't be recreated

  return (
    <div style={{ padding: "20px" }}>
      <h2>Search Page</h2>
      <SearchInput onSearch={fetchResults} />
      <ul>
        {results.map((res, i) => (
          <li key={i}>{res}</li>
        ))}
      </ul>
    </div>
  );
}

Where useCallback Helps in the Real World

Form inputs where change handlers are passed to deeply nested components.

Buttons and menus in large UIs to avoid re-rendering child components unnecessarily.

Debounced or throttled API calls to avoid function recreation resetting timers.

React.memo with functions as props â€” prevents child components from thinking props have changed.

ðŸ’¡ Difference from useMemo:

useMemo memoizes a value (result of a calculation).

useCallback memoizes a function (so its reference stays the same).
*****************************************************************useMemo+useCallback***********************************************************************
import React, { useState, useMemo, useCallback } from "react";

// Child table component
const DataTable = React.memo(function DataTable({ data, onSort }) {
  console.log("Rendering DataTable...");
  return (
    <table border="1" cellPadding="5" style={{ width: "100%" }}>
      <thead>
        <tr>
          <th onClick={() => onSort("id")}>ID â–²â–¼</th>
          <th onClick={() => onSort("name")}>Name â–²â–¼</th>
        </tr>
      </thead>
      <tbody>
        {data.map((row) => (
          <tr key={row.id}>
            <td>{row.id}</td>
            <td>{row.name}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
});

export default function App() {
  const [search, setSearch] = useState("");
  const [sortField, setSortField] = useState(null);
  const [sortAsc, setSortAsc] = useState(true);

  // Simulate large dataset
  const products = useMemo(
    () =>
      new Array(5000).fill(0).map((_, i) => ({
        id: i + 1,
        name: `Product ${Math.floor(Math.random() * 1000)}`
      })),
    []
  );

  // Filtering (memoized so it only recalculates when search changes)
  const filteredProducts = useMemo(() => {
    console.log("Filtering data...");
    return products.filter((p) =>
      p.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [products, search]);

  // Sorting (memoized so it only recalculates when filteredProducts, sortField, or sortAsc changes)
  const sortedProducts = useMemo(() => {
    console.log("Sorting data...");
    if (!sortField) return filteredProducts;
    return [...filteredProducts].sort((a, b) => {
      if (a[sortField] < b[sortField]) return sortAsc ? -1 : 1;
      if (a[sortField] > b[sortField]) return sortAsc ? 1 : -1;
      return 0;
    });
  }, [filteredProducts, sortField, sortAsc]);

  // Memoized sort function to prevent DataTable from re-rendering unnecessarily
  const handleSort = useCallback(
    (field) => {
      if (sortField === field) {
        setSortAsc(!sortAsc); // toggle direction
      } else {
        setSortField(field);
        setSortAsc(true);
      }
    },
    [sortField, sortAsc]
  );

  return (
    <div style={{ padding: "20px" }}>
      <h2>Product Table</h2>
      <input
        type="text"
        placeholder="Search products..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        style={{ marginBottom: "10px", padding: "5px" }}
      />
      <DataTable data={sortedProducts.slice(0, 20)} onSort={handleSort} />
    </div>
  );
}
___________________________________________________________ðŸŽª useReducer ðŸŽª__________________________________________________________________________________________

3. useReducer Hook
The useReducer hook is a more advanced state management tool than useState. It is typically used when you have complex state logic 
that involves multiple sub-values or when the next state depends on the previous state.

Syntax:

const [state, dispatch] = useReducer(reducer, initialState);
reducer: A function that receives the current state and an action, and returns the new state.
initialState: The initial value of the state.
dispatch: A function to send actions to the reducer.
Example:

import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
    </div>
  );
}
In this example:

useReducer manages the counter state by dispatching actions to a reducer function that handles the state changes based on the 
action type.

Key Differences:

useMemo: Memoizes the result of a function to optimize performance.

useCallback: Memoizes a function itself to prevent unnecessary re-creations.

useReducer: An alternative to useState for managing complex state logic.

These hooks are especially useful when dealing with performance optimization and more complex state management in React applications.
